## Overview

Buffer overflow is the most common vulnerability found in software applications that can lead to arbitrary code execution and more. These vulnerabilities are usually caused by the use of insecure functions that do not check bounds. In this Proof of Concept (PoC), I have demonstrated how an attacker can exploit the buffer overflow vulnerability when the application uses insecure functions such as gets.

## Build
```
gcc -o main main.c
```

## Disable ASLR
ASLR (Address Space Layout Randomization) is a security technique that allows the operating system to shuffle the positions of key data areas of a process, including the base of the executable and the positions of the stack, heap, and libraries. This method is effective against buffer overflow and is enabled by default. Therefore, we need to disable it using the following command:

```
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```

Also, ensure that you do not compile with the GCC flag `-fstack-protector`, which inserts a stack canary to detect the execution of buffer overflows. An interesting talk about the life and death of various security measures can be found [here](https://www.youtube.com/watch?v=WtlC2GaoFf8).

## Steps
After compiling and disabling ASLR:

1. Use gdb ./main and info address hook to find the address of the hook function.
2. Prepare a payload in such a way that the buffer in test2 is overflowed, and the return address on the stack is overwritten with the address of the hook function.

Example:
```
┌──(kali㉿kali)-[~/Desktop/research]
└─$ ./main                                               
AAAAAAAAAABBBBCCCCCC00iQUUUU
Test value is: 5
exploited buffer overflow vulnerability
```

## More information
About [-fstack-protector](https://developers.redhat.com/articles/2022/06/02/use-compiler-flags-stack-protection-gcc-and-clang): A stack canary is a rudimentary check for buffer overflows on the stack. The canary is an extra word of memory at the end of the stack frame with a value set at runtime. This value, presumably unknown to the attacker, is checked for modification before jumping out of the function. A modification indicates the detection of stack smashing, followed by a termination routine.
